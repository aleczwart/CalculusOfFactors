% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fct_equiv.R
\name{fct_equiv}
\alias{fct_equiv}
\title{Equivalence of factors}
\usage{
fct_equiv(f, g, ordered = FALSE)
}
\arguments{
\item{f}{factor}

\item{g}{factor, of length equal to \code{f}.}

\item{ordered}{logical: Should \code{\link{fct_equiv}} also
require identical level order encoding ('ordered equivalence')?
Default is \code{ordered=FALSE}.}
}
\value{
Logical \code{TRUE} or \code{FALSE} value.
}
\description{
Compare factors \code{f} and \code{g} for 'equivalence', meaning
that the two factors define the same partition/grouping,
regardless of differences in level labels between the factors.
}
\details{
Function \code{fct_equiv} (along with its binary operator aliases
\code{\link{\%is_equiv_to\%}} and
\code{\link{\%is_ordered_equiv_to\%}} compares two factors for
equivalence, meaning that the two factors define the same
partition/grouping, regardless of differences in level labels
between the two factors.

The weaker condition of \emph{unordered} equivalence
(\code{ordered=FALSE}, the default) implies that the factor level
order encodings need not be identical between the two factors.

The stronger condition of \emph{ordered} equivalence
(\code{ordered=TRUE}) requires that the level order
\emph{encodings} be identical between the two factors, and hence
that \code{as.integer(f)} is identical to \code{as.integer(g)}.

Regarding unused levels: If one or other of the factors has unused
levels, these will be \emph{ignored} in testing for unordered
equivalence - factors are compared on the basis of the levels that
are used, only.  In checking for ordered equivalence, unused
levels may effect the level encoding of a factor, depending upon
where the unused levels occur in the level order.  The key thing
to remember is that two factors \code{f} and \code{g} are regarded
as 'ordered equivalent' if and only if
\code{as.integer(f)==as.integer(g)} is \code{TRUE}.  See the
examples below for an illustration of the ways in which unused
levels may, or may not affect ordered equivalence status.

Note that, consistent with R's general philosophy, factors
containing \code{NA} values will return an \code{NA} result from
\code{fct_equiv}.
}
\examples{
f1 <- factor(c("a", "a", "b", "b", "c", "c", "a", "a"))

## Equivalent to f1 - same grouping, different assignment of labels to
## levels:
f2 <- factor(c("c", "c", "b", "b", "a", "a", "c", "c"))
fct_equiv(f1,f2)
## However, level order encoding is different, so factors are not
## order equivalent:
fct_equiv(f1,f2,ordered=TRUE)

## Equivalent to f1 - same grouping, different labels:
f3 <- factor(c("x", "x", "y", "y", "z", "z", "x", "x"))
fct_equiv(f1,f3)
## Level order encoding is identical, so factors are also order
## equivalent:
fct_equiv(f1,f3,ordered=TRUE)

## Equivalent to f1 - same grouping, different level order:
f4 <- factor(c("a", "a", "b", "b", "c", "c", "a", "a"),
             levels=c("b", "c", "a"))
fct_equiv(f1,f4)
## With a different level order, the factors are not order equivalent:
fct_equiv(f1,f4,ordered=TRUE)

## Not equivalent to f1 - different grouping:
f5 <- factor(c("a", "a", "a", "b", "c", "c", "a", "a"))
fct_equiv(f1,f5)
## Unordered non-equivalence implies ordered non-equivalence:
fct_equiv(f1,f5,ordered=TRUE)

## Not equivalent to F1 - different grouping (with fewer levels):
f6 <- factor(c("a", "a", "a", "b", "b", "b", "b", "b"))
fct_equiv(f1,f6)

}
\author{
Alexander Zwart <alec.zwart at csiro.au>
}
